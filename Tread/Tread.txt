## Thread(스레드)

프로그램 —클릭→ 프로세스(여러개 들어가면 멀티 프로세스)

- 프로세스 : 일반저긍로 cpu에 의해 메모리에 올려저 실행 중인 프로그램. 자신만의 메모리 공간을 포함한 독립적인 실행 환경.

→ 프로그램 중 일부는 여러 프로세스간의 상호작용으로 이루어짐

- 스레드 : 프로세스 안에서 실질적으로 작업을 실핼하는 단위

→ 프로세스에는 적어도 한개 이상의 스레드가 존대

→ main 스레드 하나로 시작하여 스레드를 추가 생성하게 되면 멀티 스레드 환경이 구성된다

→ 프로세스의 리소스를 공유하기 때문에 효율적

- 싱글 스레드 : 하나의 스레드로 구성 (한가지의 기능만 가능)
- 멀티 스레드 : 여러 스레드로 구성(여러 기능 가능)

⇒ 싱글 스레드도 사용하지만 대부분은 멀티 스레드 활용

참고 ::

[자바를 자바 26 (Multithreaded Programming with Java (2)) : Thread States, Daemon Thread](https://80000coding.oopy.io/468a1731-d0b8-4aab-8c05-ceda9c13b8f2)

 : 프로세스 안에 실질적으로 작업을 실행하는 단위(프로그램 실행의 가장 작은 단위)

→ 프로세스에는 적어도 한개 이상의 스레드가 있으며, Main 스레드 하나로 시작하여 스레드를 추가 생성하게 되면 멀티 스레드 환경이 만들어진다

→ 이러한 스레드는 프로세스의 리소스를 공유하기 때문에 효율적이기니하지만 잠재적인 문제점에 노출되기도 한다

- 자바에서 스레드를 만드는 방법 2가지
1. Thread 클래스를 상속받는 방법
2. Runnable 인터페이스를 구현하는 방법

→ runnable 인터페이스로 구현한 class는 thread말고도 다양하게 사용할 수 있다
→ Thread.currentThread().getName() : 실행 중인 Thread의 주소값을 사용해야한다면 getName()으로만 진행할 수 없기에 정적 메소드인 currentThread()를 함께 사용해 주소값을 사용할 수 있도록 한다

<aside>
📎 JOptionPane 자주쓰는 메소드

[[JAVA] JOptionPane 자주쓰는 메소드 사용법](https://shin-01.tistory.com/34)

참고::

</aside>

- Thread 특징
1. 순서대로 실행되지 않는다 → start() 에 순서대로 들어가도 그 순서대로 시작 되지 않는다(순서를 예측 불가능)
2. 끝나는 순서도 정해져 있지 않는다

- sleep
- 현재 쓰레드 멈추기
- 자원을 놓아주지는 않고, 제어권을 넘겨주므로 데드락이 발생할 수 있음
- interupt
- 다른 쓰레드를 깨워서 interruptedException을 발생시킴
- interupt가 발생한 쓰레드는 예외를 catch 하여 다른 작업을 할 수 있다.
- join
- 다른 쓰레드의 작업이 끝날 때까지 기다리게 한다
- 쓰레드의 순서를 제어할 때 사용할 수 있다

Thread 생성하고 동작 시킴에 있어서 알아두어야 할점

⇒ 스레드 객체를 생성하고 실행요청을 하더라도 스레드가 실행되는 것은 전적으로 JVM에 의한 스케쥴러에 따른다.
⇒ 쓰레드는 시간 내에 자원을 필요로 한다

⇒ 시간이 지나면 실행대기 상태로 다시 돌아간다(Yield() : 현재 쓰레드가 뒤의 쓰레드에게 양보할 경우 사용, 현재 쓰레드는 맨 뒤로 돌아간다)

⇒ 시간내에 파일이 전송(stop()) 되면 소멸된다

⇒ 실행상태에서 상황에 따라 강제로 멈출 수도 있다(일시정지 , wait() →notify()로 일시정지 풀기

⇒ suspend() : 일시정지를 누른 상태 → (ex. 동영상 일시정지 버튼)

⇒ resume() : 일시정지 상태에서 play → (ex. 동영상 재생 버튼)

⇒ sleep() : 시간이 지나면 time-out에 의해서 실행 대기 상태로 들어간다

- interrupt()  : sleep이나 Join이 걸려있는 메소드를 강제로 실행되도록!suspemd

→ interrupted 속성(boolean 타입) : interrupt() 호출되어지면 변수의 값이 변경된다

→ true와 false가 바뀐다

⇒ isInterrupted()

→ interttupted 속성값을 반환한다

- interrupt()

→ InterruptedException 타입의 예외를 발생시킨다

→ sleep(), wait(), join() 일시 정지된 쓰레드를 실행 대기 상태로 만든다

Thread의 경쟁 문제
→ 순서를 안지키다보니 원하지 않은 데이터가 나올 수도 있다

⇒ 동기화 : 먼저 진행한 작업이 완료 된후 다음 작업이 진행되도록

- 동기화
→ sleep의 대기 시간동안 다른 값이 들어와 결론적으로 -값까지 나오기 때문에 이를 해결해야 한다

⇒ 제어를 해야 한다 → 종료가 된 다음에 다음 값이 들어오도록(동기화)⇒ lock을 건다.
Thread 동기화는 메소드에 적용한다
